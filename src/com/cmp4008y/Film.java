package com.cmp4008y;

import java.util.*;

/**
 * This class contains methods that helps with searching and querying the ArrayList of HasMaps
 * generated by calling the filmCollection attribute of a FilmDatabase class.
 *
 * @author [Owusu K](https://github.com/nanacnote)
 */
public class Film {

    private final ArrayList<HashMap<String, String>> filmCollection;
    private final ArrayList<HashMap<String, String>> mutableFilmCollection;


    /**
     * Constructor method which initialised an instance of the Film class.
     * <p>
     * It begins by creating an instance of the FilmDatabase class and immediately calls the filmCollection
     * attribute of that class.
     * <p>
     * It also creates a private empty ArrayList which will be used to hold the mutating values from applying
     * methods on the filmCollection.
     */
    public Film()
    {
        this.filmCollection = new FilmDatabase().filmCollection;
        this.mutableFilmCollection = new ArrayList<>();
    }

    /**
     * This method takes in a HashMap as parameter and parses the values to return
     * a string in a format similar to the line by line film entries in the film.txt
     * file.
     *
     * @param filmHashMap HashMap object with key/value pairs consistent to the return shape.
     * @return string similar to line by line entries in film.txt.
     */
    private String toString(HashMap<String, String> filmHashMap)
    {
        return filmHashMap.get("title") + ","
                + filmHashMap.get("year") + ","
                + filmHashMap.get("certificate") + ","
                + filmHashMap.get("genre") + ","
                + filmHashMap.get("duration") + ","
                + filmHashMap.get("rating");
    }

    /**
     * This method calls the implemented comparator interface to help with sorting.
     * It requires a param which is used to determine what custom algorithm to override
     * the compare() method with
     *
     * @param section string indicating what section of the entry should determine the sorting.
     *                (eg. duration, year, ratings, titleLength etc)
     * @return current Film instance
     */
    public Film sortBy(String section)
    {
        // refer to notes A1 at bottom for info on this expression
        ArrayList<HashMap<String, String>> copyOfFilmCollection = new ArrayList<>(this.mutableFilmCollection.isEmpty() ? this.filmCollection : this.mutableFilmCollection);

        this.mutableFilmCollection.clear();

        copyOfFilmCollection.sort(new CustomComparator(section));
        this.mutableFilmCollection.addAll(copyOfFilmCollection);

        return this;
    }

    /**
     * This method mutates a copy of the filmCollection (ArrayList of HashMaps) into another
     * filmCollection (ArrayList of HashMaps) but this time the members of this mutated filmCollection
     * are only those which satisfy the filter value requirements as given in the parameters.
     *
     * @param section     Section of the film entry to use as filter
     * @param filterValue the value in the section to filter for
     * @return current Film instance
     */
    public Film filterBy(String section, String filterValue)
    {
        // refer to notes A1 at bottom for info on this expression
        ArrayList<HashMap<String, String>> copyOfFilmCollection = new ArrayList<>(this.mutableFilmCollection.isEmpty() ? this.filmCollection : this.mutableFilmCollection);

        this.mutableFilmCollection.clear();

        for (HashMap<String, String> film : copyOfFilmCollection)
        {
            // removes quotation marks from section if any exist
            String quotesTrimmer = film.get(section).replace("\"", "");

            // cast section string to set, if it has multiple values separated by / eg. genre section
            Set<String> multipleFilterValues = Set.of(quotesTrimmer.split("/"));

            if (multipleFilterValues.contains(filterValue))
            {
                this.mutableFilmCollection.add(film);
            }

        }
        return this;
    }

    /**
     * This method helps to slice a filmCollection ArrayList into smaller ArrayList.
     * Both parameter values are included in the slice eg sliceResult(1, 3) will start from
     * the first entry in the list, the second entry and the third entry.
     * <p>
     * To start counting from the end of the ArrayList the first parameter must be -1
     * eg sliceResult(-1,3) will start from the last entry, the last but one entry and the
     * last but 2 entry.
     * <p>
     * To select entries up to and including the last one set the second parameter to 0.
     * eg sliceResult(2, 0) will include all the values from the second element to through
     * to the last element.
     *
     * @param fromInclusive integer number to start from
     * @param toInclusive   integer number to end at inclusive
     * @return current Film instance
     */
    public Film sliceResult(int fromInclusive, int toInclusive)
    {
        // refer to notes A1 at bottom for info on this expression
        ArrayList<HashMap<String, String>> copyOfFilmCollection = new ArrayList<>(this.mutableFilmCollection.isEmpty() ? this.filmCollection : this.mutableFilmCollection);

        this.mutableFilmCollection.clear();

        if (fromInclusive < 0)
        {
            Collections.reverse(copyOfFilmCollection);
            fromInclusive *= -1;
        }

        if (toInclusive == 0)
        {
            toInclusive = copyOfFilmCollection.size();
        }

        if (fromInclusive == 0 || fromInclusive > copyOfFilmCollection.size() || toInclusive > copyOfFilmCollection.size())
            throw new IllegalArgumentException("Either the \"from\" or \"to\" parameter is out of range");

        for (int i = fromInclusive - 1; i < toInclusive; i++)
        {
            this.mutableFilmCollection.add(copyOfFilmCollection.get(i));
        }

        return this;
    }

    /**
     * This method gets a value from each entry of filmCollection and sets them to an ArrayList.
     * The value it gets from the entry is based on the param provided.
     *
     * @param section the key in the HashMap whose value is needed
     * @return ArrayList of values matching parameter.
     */
    public ArrayList<String> getValueOf(String section)
    {

        if (!this.mutableFilmCollection.isEmpty())
        {
            ArrayList<String> valuesList = new ArrayList<>();

            for (HashMap<String, String> film : this.mutableFilmCollection)
            {
                valuesList.add(film.get(section));
            }
            return valuesList;
        }
        return new ArrayList<>();
    }

    /**
     * This method prints the film entries in the filmCollection to the console.
     * This is done line by line and in the same format as in the film.txt file
     */
    public void printResult()
    {

        for (HashMap<String, String> film : this.mutableFilmCollection)
        {
            System.out.println(toString(film));
        }

    }

    /**
     * subclass implementing Comparator to help in sort elements in a ArrayList of HashMaps.
     */
    static class CustomComparator implements Comparator<HashMap<String, String>> {

        private final String key;

        private CustomComparator(String key)
        {
            this.key = key;
        }


        /**
         * Overridden compare method contain custom algorithms for comparing integers, doubles
         * and string length.
         *
         * @param o1 first  element in Arraylist of super class object
         * @param o2 second element in Arraylist of super class object
         * @return 1, 0,-1
         */
        @Override
        public int compare(HashMap<String, String> o1, HashMap<String, String> o2)
        {
            if (key.equals("duration") || key.equals("year"))
            {
                int first = Integer.parseInt(o1.get(key));
                int second = Integer.parseInt(o2.get(key));
                return Integer.compare(first, second);
            }
            if (key.equals("rating"))
            {
                double first = Double.parseDouble(o1.get(key));
                double second = Double.parseDouble(o2.get(key));
                return Double.compare(first, second);
            }
            if (key.equals("titleLength"))
            {
                int first = o1.get("title").length();
                int second = o2.get("title").length();
                return Integer.compare(first, second);
            }
            return o1.get(key).compareTo(o2.get(key));
        }
    }

}